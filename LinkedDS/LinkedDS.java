/** A linked implementation of the PrimQ<T> and Reorder interfaces. *  This implementation is mostly taken from the Carrano LList.  It is modified *  for Assignment 2.  This code MUST BE USED AS IS for Assignment 2. * @author Sherif Khattab (Adapted  from Dr. John Ramirez's Spring 2017 CS 0445 Assignment 2 code) * * @param <T> The type of entries stored in the LinkedDS *  *//**   A linked implementation of the ADT list.   @author Frank M. Carrano   @version 2.0 */ import java.util.Random;public class LinkedDS<T> implements PrimQ<T>, Reorder{	protected Node firstNode; // reference to first node	protected int  numberOfEntries; 	public LinkedDS()	{		initializeDataFields();	} // end default constructor	// Return the number of items currently in the PrimQ	public int size(){		return numberOfEntries;		}	// Reset the PrimQ to empty status by reinitializing the variables	// appropriately	public final void clear() // note the final method	{		initializeDataFields();	} // end clear	private void initializeDataFields() {		firstNode = null;		numberOfEntries = 0;	}	@Override	public T removeItem() throws EmptyQueueException {		T result = null;                           // return value		if(!isEmpty()){			result = firstNode.getData();        // save entry to be removed 			firstNode = firstNode.getNextNode();			numberOfEntries--;		} else {			throw new EmptyQueueException(					"Trying to remove from an empty PrimQ.");		}				return result;    // return removed entry	}	// Copy constructor.  This is a "deepish" copy so it will make new	// Node objects for all of the nodes in the old list.  However, it	// is not totally deep since it does NOT make copies of the objects	// within the Nodes -- rather it just copies the references.	public LinkedDS(LinkedDS<T> oldList)	{		if (oldList.size() > 0)		{			// Special case for first Node since we need to set the			// firstNode instance variable.			Node temp = oldList.firstNode;		// front of old list			Node newNode = new Node(temp.data);	// copy the data			firstNode = newNode;				// set front of new list			// Now we traverse the old list, appending a new Node with			// the correct data to the end of the new list for each Node			// in the old list.  Note how the loop is done and how the			// Nodes are linked.			Node currNode = firstNode;			temp = temp.next;			while (temp != null)			{				currNode.next = new Node(temp.data);				temp = temp.next;				currNode = currNode.next;			}			numberOfEntries = oldList.numberOfEntries;		}				}	// Make a StringBuilder then traverse the nodes of the list, appending the	// toString() of the data for each node to the end of the StringBuilder.	// Finally, return the StringBuilder as a String.	public String toString()	{		StringBuilder b = new StringBuilder();		for (Node curr = firstNode; curr != null; curr = curr.next)		{			b.append(curr.data.toString());			b.append(" ");		}		return b.toString();	}	// Returns a reference to the node at a given position.	// Precondition: List is not empty;	//               1 <= givenPosition <= numberOfEntries	   	private Node getNodeAt(int givenPosition)	{		assert !isEmpty() && (1 <= givenPosition) && (givenPosition <= numberOfEntries);		Node currentNode = firstNode;		// traverse the list to locate the desired node		for (int counter = 1; counter < givenPosition; counter++)			currentNode = currentNode.getNextNode();		assert currentNode != null;		return currentNode;	} // end getNodeAt	@Override	public void addItem(T item)  {		Node newNode = new Node(item);		if (isEmpty())			firstNode = newNode;		else  // add to end of non-empty list		{			Node lastNode = getNodeAt(numberOfEntries);			lastNode.setNextNode(newNode); // make last node reference new node		} // end if			numberOfEntries++;			}	@Override	public boolean isFull() {		return false;	}	@Override	public boolean isEmpty() {		boolean result;		if (numberOfEntries == 0)		{			assert firstNode == null;			result = true;		}		else		{			assert firstNode != null;			result = false;		} // end if		return result;	}	@Override	public void reverse() {		Node prev = null;		Node curr = firstNode;		Node next = null;		while(curr != null){			next = curr.getNextNode();			curr.setNextNode(prev);			prev = curr;			curr = next;		}		firstNode = prev;	}	@Override	public void shiftRight() {		Node holderNode = firstNode;		Node prevNode = null;		for(int i=1; i < numberOfEntries; i++){			if(i == numberOfEntries-1){				prevNode = holderNode;			}			holderNode = holderNode.getNextNode();		}		prevNode.setNextNode(null);		holderNode.setNextNode(firstNode);		firstNode = holderNode;			}	@Override	public void shiftLeft() {		Node end = firstNode;		for(int i=1; i < numberOfEntries; i++){			end = end.getNextNode();		}		end.setNextNode(firstNode);		Node holder = firstNode;		firstNode = firstNode.getNextNode();		holder.setNextNode(null);	}	@Override	public void leftRotate(int num) {		if(num < 0){			num = numberOfEntries - (-num);		}		if(numberOfEntries > 0){		Node end = firstNode;				for(int i=0; i < numberOfEntries-1; i++){			end = end.getNextNode();		}			while(num > 0){				Node temp = firstNode.getNextNode();				firstNode.setNextNode(null);				end.setNextNode(firstNode);				end = firstNode;				firstNode = temp;				num--;			}					}				}	@Override	public void rightRotate(int num) {		//Runtime: O(N + W) 		//where N is N elements in the linkedDS and W is W elements after the newhead.		// is faster than O(num * N) from before		if(num > numberOfEntries){			num = num % numberOfEntries;		}		else if(num < 0){			num = numberOfEntries - (-num);		}		int root = numberOfEntries - num;		if(numberOfEntries > 0 && root > 0){			Node end = firstNode;			Node newhead = null;			Node newend = null;			for(int i= 1; i < numberOfEntries; i++){				end = end.getNextNode();				if(i == root-1){					newend = end;					newhead = end.getNextNode();				}			}			Node holder = newhead;			while(holder.getNextNode() != null){				holder = holder.getNextNode();			}			holder.setNextNode(firstNode);			firstNode = newhead;			newend.setNextNode(null);			// Runtime: O(num * N) where N is the number of elements of the list			// while(num > 0){			// 	num--;			// 	Node end = firstNode;			// 	Node holder = null;			// 	for(int i=0; i < numberOfEntries-1; i++){			// 		end = end.getNextNode();			// 		if(i == (numberOfEntries-3))			// 			holder = end;			// 	}			// 	end.setNextNode(firstNode);			// 	holder.setNextNode(null);			// 	firstNode = end;			// 	end = holder;			// }		}	}	@Override	public T head() throws EmptyQueueException {		if(numberOfEntries <= 0 || firstNode == null)			throw new EmptyQueueException("List is Empty");		else			return firstNode.getData();	}		//Algorithm: 	//Iterate over N entries in the linked list and perform Fisher-Yates shuffle.	// Runtime: O()	@Override	public void shuffle(int seed) {			Random seeder = new Random(seed);		for(int i= numberOfEntries; i > 0; i--){			int index = seeder.nextInt(i);			T temp = getItem(index);			setItem(getItem(i), index);			setItem(temp, i);		}	}	public T getItem(int i ){		return this.getNodeAt(i).data;	}	public void setItem(T data, int i){		this.getNodeAt(i).data = data; 	}		@Override	public void leftShift(int num) {				if(numberOfEntries >  0 && num <= numberOfEntries){					while(num > 0 && numberOfEntries > 0){				firstNode = firstNode.getNextNode();				num--;				numberOfEntries--;			}		}			}	@Override	public void rightShift(int num) {		Node lastNode = firstNode;		Node holder = null;		for(int i=0; i < (numberOfEntries - (num+1)); i++){			lastNode = lastNode.getNextNode();		}		lastNode.setNextNode(null);		numberOfEntries -= (num);	}	// Note that this class is protected so you can access it directly from	// your LinkedDS and ReallyLongInt classes.  However, in case you	// prefer using accessors and mutators, those are also provided here.	protected class Node	{		private T data; 	// entry in list		private Node next; 	// link to next node		protected Node(T dataPortion)		{			this(dataPortion, null);		} // end constructor		protected Node(T dataPortion, Node nextNode)		{			data = dataPortion;			next = nextNode;		} // end constructor		protected T getData()		{			return data;		} // end getData		protected void setData(T newData)		{			data = newData;		} // end setData		protected Node getNextNode()		{			return next;		} // end getNextNode		protected void setNextNode(Node nextNode)		{			next = nextNode;		} // end setNextNode	} // end Node} // end LinkedDS